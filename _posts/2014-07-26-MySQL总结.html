---
layout: post
title: "MySQL总结"
category: "数据库"
---

<div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">一. 事务隔离级别</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://en.wikipedia.org/wiki/Isolation_%28database_systems%29" style="background: transparent; margin-top: 0px;" target="_blank">WIKI</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">规定事务间的可见性。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">0. 事务的 ACID</h2>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. read uncommited</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最弱，事务的所有动作对其他事务都是立即可见的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">问题： <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">脏读</code> </strong><br/>即看到其他事务中间状态的数据。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. read commited</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只能读到其他事务已提交的数据，中间状态的数据则看不到，解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">脏读</code>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">问题：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">non-repeatable read</code></strong><br/>同一事务内，对同一条记录，两次读取间如果有其他事务对其的更新提交了，则看到的数据不同。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. repeatable read</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">non-repeatable read</code>的问题，保证在一个事务内，对同一条记录的重复读都是一致的。<em>是InnoDB的默认隔离级别。</em></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">问题：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">phantom read</code></strong><br/>对于某个范围的查询，两次查询间如果有其他事务在该范围内进行了删除或新增，则第二次查询会发现多/少了某些记录。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">对<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">phantom read</code>的解决方案：</strong><br/>引入<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">range lock</code>区间锁，读/写时，除了对满足条件的记录加锁，记录之间的区间也加锁，保证不会出现区间内的插入操作。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. serial</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最高，所有事务都是串行的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">可以通过锁实现不同事务间对资源访问的互斥，从而实现以上事务隔离级别。但在</p>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">二. 并发</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 锁优化1：拆分，读写锁</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">读锁 -- 共享锁 -- shared<br style="margin-top: 0px;"/>写锁 -- 排他锁 -- exclusive</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. 锁优化2：降低粒度</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><em style="margin-top: 0px;">表锁由 mysql服务器 实现，行锁由 存储引擎 实现。</em></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">表锁</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">显式的表锁：<br style="margin-top: 0px;"/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">lock table xxx read/write;</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM几乎完全依赖MySQL服务器提供的表锁机制。</p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">使用MyISAM时对锁的优化：</h4>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">缩短锁定时间：拆分query / 索引</li>
<li style="line-height: 1.6;">打开concurrent insert(在尾部并发insert)</li>
<li style="line-height: 1.6;">根据需要设置读写的优先级。默认写大于读</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">行锁</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB实现了行锁，基于索引的 index-row locking，<strong style="font-weight: bold; margin-top: 0px;">如果锁了次级索引中的记录，则对应主索引中的记录也会被锁住</strong>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">update/delete/insert会加x锁</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">查询时也可以设置显式加锁：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... lock in shared mode</code>: s lock</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... for update</code>: x lock</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">two-phase locking protocol</code>：事务内部获得的锁在提交时一起释放</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. MVCC</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB 在行锁的基础上还支持MVCC。行锁可以实现各个数据库事务隔离级别，MVCC 则是基于行锁的并发控制的一个优化，简单的说，MVCC为某条记录创建多个snapshot，不同事务读取各自的snapshot，互不影响，它的作用主要在于：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">使普通的select避免加锁，提高并发</li>
<li style="line-height: 1.6;">不用锁也能实现 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">read commited</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">repeatable read</code> 事务隔离级别的语义</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">MVCC 只工作在RC &amp; RR两个隔离级别下，Read uncommited 隔离级别不支持 MVCC，在这个级别下每次都是读取最新版本的数据行；Serializable 也不支持 MVCC，该级别下每个 read 动作都会为记录加上读锁。</strong></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">MySQL的两种read方式</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">snapshot read(non-lock) / consistent read</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">current read(lock) / lock read</code>:</li>
</ol>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">a. "snapshot read"</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">普通的select就是snapshot read，读 MVCC 的快照，不加锁, 但是不同的隔离级别中的行为是不一样的:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">RC: 最近的snapshot  -- read commited，看到其他事务的动作</li>
<li style="line-height: 1.6;">RR: 事务开始时的snapshot  -- <strong style="font-weight: bold; margin-top: 0px;">repeatable  read</strong>，一致性</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">可以看到，snapshot read 在RC和RR中的工作方式都满足其隔离级别的定义。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html" style="background: transparent; margin-top: 0px;" target="_blank">Consistent Nonlocking read</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">If the transaction isolation level is REPEATABLE READ (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction. </p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">You can get a fresher snapshot for your queries by committing the current transaction and after that issuing new queries.</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">With READ COMMITTED isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.</p>
</blockquote><h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">b. "current read / lock read"</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">lock read 操作的是数据的最新版本，且对记录加锁。以下动作属于 lock read：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... lock in shared mode</code>: s lock</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">select... for update</code>: x lock</li>
<li style="line-height: 1.6;">DML（insert/delete/update）也属于 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">lock read</code></li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-locking-reads.html" style="background: transparent; margin-top: 0px;" target="_blank">SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE Locking Reads</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">该模式的一个作用是 <strong style="font-weight: bold; margin-top: 0px;">在RR隔离级别上</strong> 解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phantom read</code>的问题，这是通过<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">gap lock</code>实现的。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">4. gap lock &amp; phantom read</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">repeatable read</code>级别上, <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">lock read</code> 时使用了 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">gap-key lock</code> 解决 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phathom read</code> 问题: 不仅锁找到的记录，还锁区间，保证区间内的值无法被插入。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意，无法使用索引时会走主索引实现全表扫描，此时会给所有的记录加上record lock，并对其所有的区间加gap lock，表完全锁死，此时只能进行 snapshot read，极大地降低并发，这就是为何update/delete尽量要走索引的原因。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">普通的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">snapshot read</code> 依然有<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phantom read</code>，只能保证<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">可重复读</code>；只有 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">lock read</code> 既解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">phantom read</code>，又保证了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">可重复读</code>。</li>
<li style="line-height: 1.6;">RC级别的 lock read 没有<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">gap lock</code>，只会加 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">record lock</code>。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://hedengcheng.com/?p=771" style="background: transparent; margin-top: 0px;" target="_blank">何登成的《MySQL 加锁处理分析》</a><br/><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html" style="background: transparent;" target="_blank">innodb-record-level-locks`</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">MySQL/InnoDB定义的4种隔离级别：</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Read Uncommited<br style="margin-top: 0px;"/>可以读取未提交记录。此隔离级别，不会使用，忽略。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Read Committed (RC)<br style="margin-top: 0px;"/>快照读忽略，本文不考虑。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Repeatable Read (RR)<br style="margin-top: 0px;"/>快照读忽略，本文不考虑。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Serializable<br style="margin-top: 0px;"/>从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</p>
</blockquote><h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 查询锁的争用情况</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">表锁<br style="margin-top: 0px;"/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">show status like 'table%'</code><br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">Table_locks_immediate</code>:立即获得表锁的次数<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">Table_locks_waited</code>:需要等待获得表锁的次数</li>
<li style="line-height: 1.6;">innodb的行锁<br style="margin-top: 0px;"/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">show status like 'innodb_row_lock'</code><br/>current_waits:<br/>waits:<br/>time:<br/>time_avg:<br/>time_max:</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">三. 优化query (粗略)</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">定位瓶颈</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">IO or CPU?</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">工具</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">explain &amp; profile</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">基本原则</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">join时小结果集驱动大结果集</li>
<li style="line-height: 1.6;">利用索引完成排序/分组</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">只取需要的列（？）<br style="margin-top: 0px;"/> a. network<br/> b. 不能使用Covering index<br/> c. 优化排序</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">仅仅使用最有效的过滤条件<br style="margin-top: 0px;"/> 建立索引的字段越小越好，减少IO</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">避免复杂join和子查询<br style="margin-top: 0px;"/> 对于MyISAM，join会锁住所有相关的表（s lock），可能阻塞DML其他很长时间，此时可以在程序中做join，降低对锁的占用，减少阻塞；<br/> 对应用而言，SQL的执行时间：网络/执行（CPU+IO）/锁阻塞，优化瓶颈<br/> 子查询实现不好，不一定会走索引</p>
</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">Explain</h2>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">四. 索引</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://www.percona.com/files/presentations/percona-live/london-2011/PLUK2011-practical-mysql-indexing-guidelines.pdf" style="background: transparent; margin-top: 0px;" target="_blank">Practical MySQL indexing guidelines</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM 和 InnoDB 的索引，采用的数据结构都是B+树。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. B树和B+树</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">B树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">B树的结构类似二叉查找树，只不过节点的度远远大于2，查找的复杂度为树的高度，O(logdN)：<br style="margin-top: 0px;"/><img alt="Alt text" class="en-media" longdesc="./1402812459074.png" name="6110437c-cb5b-4148-9a0d-9cbea5a7d5fd" src="https://www.evernote.com/shard/s133/sh/d308cb41-961f-433d-ae84-98bc3015ed13/68ef39ac3bcb6b1fd5a72a8c657bacca/res/6110437c-cb5b-4148-9a0d-9cbea5a7d5fd/1402812459074.png?resizeSmall&amp;width=832" style="border: 0; max-width: 100%;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">通常会将根据硬盘上一个page的大小来调整节点的度，原因是在基于外存的查找数据结构中，性能的瓶颈在于IO，这样的处理一可以让一个节点一次IO即可读入，二可以显著降低树的高度，查找时只需几次page的IO即可定位到目标。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">B+树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">B+树是对B树的优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">只有叶子节点存data，内节点只存key；<br style="margin-top: 0px;"/> 好处：提高内节点的度，降低高度</li>
<li style="line-height: 1.6;">叶子节点加上了next指针，形成一个链表<br style="margin-top: 0px;"/> 好处：快速范围查找，只需确定起点和终点，顺序扫描即可。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1402813534888.png" name="f3392b7b-c733-4b80-ba43-d51f8cc1cf8c" src="https://www.evernote.com/shard/s133/sh/d308cb41-961f-433d-ae84-98bc3015ed13/68ef39ac3bcb6b1fd5a72a8c657bacca/res/f3392b7b-c733-4b80-ba43-d51f8cc1cf8c/1402813534888.png?resizeSmall&amp;width=832" style="border: 0; margin-top: 0px; max-width: 100%;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. MyISAM的索引</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">索引和数据分离，数据文件：堆表(按插入有序)</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">主键索引和非主键索引结构一致，叶子节点存储的是行的物理位置信息（row number）</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1402813593672.png" name="a8cab548-fa57-4191-90c6-5ff93e80c322" src="https://www.evernote.com/shard/s133/sh/d308cb41-961f-433d-ae84-98bc3015ed13/68ef39ac3bcb6b1fd5a72a8c657bacca/res/a8cab548-fa57-4191-90c6-5ff93e80c322/1402813593672.png?resizeSmall&amp;width=832" style="border: 0; margin-top: 0px; max-width: 100%;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. InnoDB的索引</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">primary index（主键索引）</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数据文件就是主键索引文件，叶子节点存真实数据，这种方式称为 聚集索引。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果没有主键，InnoDB会试着使用一个Unique Nonnullable index代替；如果没有这种索引，会定义隐藏的主键。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">secondary index</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">非主键上的索引称为次级索引，叶子节点存主键，此时需要查找两次。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">优缺点</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优点： 将相关数据保存在一起，减少IO；MyISAM访问每个行都得访问数据文件</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">缺点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">B+树的节点按page聚集，存储着数据，因此主索引叶子节点分裂的机会远远大于非聚集索引；split会导致 <ul style="margin-top: 0px; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">移动大量数据; </li>
<li style="line-height: 1.6;">需要更多空间（碎片）; </li>
<li style="line-height: 1.6;">split时会给整个索引加x锁，不可访问</li>
</ul>
</li>
<li style="line-height: 1.6;">按主键顺序插入最快；乱序插入慢(频繁分裂)，因此 <strong style="font-weight: bold; margin-top: 0px;">更适合用自增主键</strong></li>
<li style="line-height: 1.6;">secondary index包含了主键，体积可能很大，因此 <strong style="font-weight: bold; margin-top: 0px;">不适合用过长字段当主键</strong></li>
<li style="line-height: 1.6;">在secondary index上可能需要查找两次，一次查自己，一次查主索引。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. 什么样的查询条件会走索引?</h2>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">区分<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">范围查询</code>和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">等值查询</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">in</code>是多个等值查询，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">between</code>二者都有可能。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">范围查询 使用索引的方式，是先确定起点，再根据叶子节点组成的链表顺序扫描，直到终点。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">等值查询 则是从上到下搜索树。</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">假如有索引<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">&lt;a,b,c,d&gt;</code>：</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 最左前缀的等值查suoyin询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一旦出现空洞，后面的列就不能使用索引了，但空洞可以用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">in所有值</code>填充</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 范围查询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只有第一个范围查询及前面的列可以使用索引，后面的即使构成最左前缀也不会走索引。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">因此，较常进行范围查询的列要放在索引的后面。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 字符串<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">%</code>如果放在开头则无法走索引</h3>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 建立索引时的优化</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 不适合创建索引的情况</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">唯一性太差的列<br style="margin-top: 0px;"/> 引擎根据统计信息会做优化，可能建了也不走</li>
<li style="line-height: 1.6;">频繁更新的列<br style="margin-top: 0px;"/> 需要同时维护索引和数据    </li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 前缀索引 和 selectivity（选择性）</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：列太长，太消耗空间；解决方案：用前缀建立索引<br style="margin-top: 0px;"/>但是又要保证良好的selectivity<br/>selectivity = (distinct values) / all records</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 尽量使用多列复合索引而不是多个单列索引</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">减少维护索引的开销<br style="margin-top: 0px;"/>多个单列索引老版本只会选一个，5.0以后可以用index merge，扫描多个再合并结果（or/and）</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">d) 选择正确的列顺序</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">一般来说选择性高的放前面，在最初阶段就可以排除大部分记录，减少后续需要考察的数据量；</li>
<li style="line-height: 1.6;">最常用的放在前面，范围查询的字段尽量靠后。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">6. 查询优化</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 查询条件中不要对列做运算，否则无法使用索引；</h3>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 使用覆盖索引</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Covering index: 覆盖了查询的所有列，避免访问数据文件/聚集索引<br style="margin-top: 0px;"/>发起的查询被索引覆盖时，会在Extra出现Using Index</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 优化join</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MySQL只支持nested loop join，没有hash join或者sort merge join。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">nested loop join</code><br/>两层循环</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">hash join</code><br/>驱动表先构造hash table，扫描另一张表，并查找hash table看是否有对应记录</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">sort merge join</code><br/>两张表先排序，然后交替扫描进行join。这个过程类似归并排序的归并阶段</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当join无法使用索引（type是all/index/range/index_merge，用到是ref）时会用到join buffer，缓存中间的结果集</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">某些情况下拆分join效率更高：<ul style="margin-top: 0px; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">在应用端可以利用缓存</li>
<li style="line-height: 1.6;">减少MyISAM的表锁时间</li>
<li style="line-height: 1.6;">对大表用in替换join，更高效</li>
</ul>
</li>
<li style="line-height: 1.6;">减小最外层循环次数，即用小结果集驱动join（优化器会帮你挑选较小的表做驱动表）</li>
<li style="line-height: 1.6;">保证被驱动表上的join字段被索引</li>
<li style="line-height: 1.6;">只group by或order by驱动表上的列，这样可以在join前排序</li>
<li style="line-height: 1.6;">被驱动表无法走索引时，保证join buffer足够大</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">d) 优化 order by</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当不能用索引实现排序时，mysql必须对存储引擎返回的记录排序，这个过程被称为filesort（但不一定发生在磁盘上）。纯内存时快速排序，外存时分块快速排序再归并。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两种filesort算法：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">order by 字段和行指针取出，在sort buffer中排序；然后通过行指针取出需要的列。需要访问两次数据，但内存消耗少。</li>
<li style="line-height: 1.6;">一次性将所有需要的列取出，在sort buffer中排序，需要更多内存。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">参数：max_length_for_sort_data，结果集长度超过该参数时用第一种。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">对join的排序:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">如果只用了驱动表的字段排序：先排序，再join</li>
<li style="line-height: 1.6;">否则先join，结果集放temp table，然后再排序（Using temporary; Using filesort）</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><strong style="font-weight: bold; margin-top: 0px;">尽量走索引</strong><ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">order by时必须要能使用索引的最左前缀(order by+where条件中的常量组成最左前缀也可以)，且order by的方向都相同</li>
<li style="line-height: 1.6;">join时，order by的列必须引用第一个表（驱动表）</li>
</ul>
</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold; margin-top: 0px;">优化filesort</strong><ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">内存多时加大max_length_for_sort_data，返回记录小于时用新算法，大于用老算法；</li>
<li style="line-height: 1.6;">用第二种算法时，去掉不必要的返回字段（会用更多内存）</li>
<li style="line-height: 1.6;">加大sort_buffer_size，减小排序过程的IO</li>
</ul>
</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">e) 优化 group by / distinct</h3>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">group by：</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">比order by多了分组和聚合函数计算的步骤，因此优化方式和order by基本类似。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;"> 1. 走索引，可以避免额外排序</strong></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 0px; margin-bottom: 5px; font-size: 18px;">索引访问方式</h4>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">1. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">loose index scan</code>（MySQL不支持）</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">当前对 <strong style="font-weight: bold; margin-top: 0px;">范围查询</strong> 的处理方式(range scan)是<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">走叶子节点链表扫描</code>，当后续有其他列上的过滤条件时，不支持在 <strong style="font-weight: bold;">从上往下搜索的时候，对一个范围内的所有子树，利用后续列的其他条件进行查找并合并结果集</strong> 的工作方式。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">举个例子，idx(a,b,c)，where a = 1 and b &lt; 3 and c = 1，不用loose index scan时的range scan方式：</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">找到b=3的最右侧叶子节点，往前扫描，再用c=1在链表上过滤，这种方式在搜索的时候实际上只用到了ab两列;</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">但是显然有一种更好的方式，即在树上从上往下搜索到b&lt;3的所有区间后，对每个子树用c=1的条件过滤，并合并结果。这就是所谓的loose index scan。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">这就是 idx(a,b,c)少了只有a/c当查询条件是只能用到a列；ab都有范围查询只能用到a列 的根本原因。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Mysql的B+索引只支持等值查询，in实际上是和其他条件进行笛卡尔积后的多个等值查询，因此在查询b/c列时，如果用a in ('男','女')补上这个空洞时，又是可以走索引的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;">可以使用下面两种方式加速分组</strong>：</p>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">2. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">伪loose index scan</code>:</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">group by在有些情况下可以使用这种方式加速查询。<br style="margin-top: 0px;"/>idx(a,b,c)，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px;">select max(c) where ... group by a,b</code>时对每个a+b的唯一组合的区间，找到该子树的最左（右）节点，然后合并结果即可。<br/>这种工作方式和真正的loose scan类似，都是合并子树的搜索结果，但仅需要访问子树的部分节点。它的局限在于仅适用某些聚合函数如min/max，且查询字段必须在group by字段后面，二者一起组成最左前缀。</p>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">3. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">Tight index scan</code>:</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin-top: 0px;">伪loose index scan</code>类似，但需要访问整个子树，对其所有节点做分组/聚合，不能直接拿到结果。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><a href="http://docs.oracle.com/cd/E16655_01/server.121/e15858/tgsql_optop.htm#TGSQL95163" style="background: transparent; margin-top: 0px;" target="_blank">B+树索引访问方式</a></p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;"> 2. 不能用索引时，mysql必须先将数据放入临时表，然后filesort。</strong></p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">distinct：</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">与group by的实现方式是一样的，因此优化方式也类似：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">伪loose index scan</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">tight index scan</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin-top: 0px;">filesort</code>，但distinct不需要排序</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">f) count</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">count(<em style="margin-top: 0px;">): 统计结果集的行<br style="margin-top: 0px;"/>count(列/表达式): 统计值的个数，排除null<br/>MyISAM维护了表的总行数，所有没有where条件的count(</em>)很快<br/>工作方式：扫描符合条件的记录，统计<br/>一个sql语句统计不同值的count：<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px;">SELECT COUNT(color = 'blue' OR NULL) AS blue, COUNT(color = 'red' OR NULL) AS red FROM items</code><br/>很难优化，覆盖索引？</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">g) limit &amp; offset</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一般瓶颈在于扫描的数据太多，limit 10000,20会扫描10020行数据，再丢弃前10000行.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：利用covering index在索引上偏移，而不是全表上偏移 --  可以先在索引上偏移再join原表获取其他列。<br style="margin-top: 0px;"/>(没别的办法了？？)</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">h) union</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MySQL总是用temp table实现union<br style="margin-top: 0px;"/>使用union all而不是union，后者会对temp table做distinct操作，开销很大</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold; margin-top: 0px;"> 附：数据访问方式，出现在explain的type列里 </strong> </p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">(all)        Full table scan          全表扫描</li>
<li style="line-height: 1.6;">(index)      Index scan               索引全部扫描：找到最左叶子节点，然后走链表</li>
<li style="line-height: 1.6;">(range)      Range Scan               索引范围扫描：找到范围的最左（右）侧叶子，然后走链表<br style="margin-top: 0px;"/>例外：in显示的是range，但是是索引唯一扫描，等同于多个相等条件</li>
<li style="line-height: 1.6;">(ref/eq_ref) Unique Index Lookup      索引唯一扫描，走树</li>
<li style="line-height: 1.6;">(const)      Constant</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">五. 可扩展设计</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">分布式事务</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">合理设计切分规则，保证事务所需数据在同一个DB上，避免分布式事务</li>
<li style="line-height: 1.6;">拆分成小事务，app保证整体事务完整性</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">最终一致性</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">为了HA/负载均衡需要冗余数据，数据冗余的地方就存在一致性的问题</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">同一个数据只要保存在多个地方，且至少有一个地方被写，就存在一致性问题<br style="margin-top: 0px;"/>如果保存在多个地方被写，情况就更复杂了，涉及到数据的传播/并发/事务，尽量避免这个情况，保证数据在一个地方被增删改。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">shard还是一个数据在一个地方</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果session是各个容器自己管理的，因为要是强一致性的，必然需要session的复制<br style="margin-top: 0px;"/>如果每个容器有自己的本地cache，且会update/remove，和cpu的L1/L2/L3缓存的情形类似，都要实现cache的传播</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">Replication</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">Master-Slaves 读写分离，负载均衡</li>
<li style="line-height: 1.6;">Dual Master 双机热备HA</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">数据切分(shard)</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">垂直</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">按业务模块切分<br style="margin-top: 0px;"/>需要程序进行不同库之间的join</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">水平</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每个库的表结构是一样的，按id划分数据<br style="margin-top: 0px;"/>数据局部性好，很多表关联/事务能够在一个DB完成</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">结合：先垂直再水平</h3>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">切分后的整合</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">统一数据访问层 -- 路由规则/解析sql/合并结果/join/分布式事务/负载均衡都可以在这一层搞定<br style="margin-top: 0px;"/>一些开源产品：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<ol style="margin-top: 0px; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">MySQL Proxy</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word; margin-top: 0px;">Amoeba (JDBC以下)<br style="margin-top: 0px;"/> query路由/过滤，负载均衡，读写分离，HA<br/> 主要解决：</p>
<ol style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">数据切分后复杂数据源整合;</li>
<li style="line-height: 1.6;">提供数据切分规则并降低数据切分规则给数据库带来的影响;</li>
<li style="line-height: 1.6;">降低数据库与客户端的连接数;</li>
<li style="line-height: 1.6;">读写分离路由</li>
</ol>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Amoeba for MySQL/Aladin</p>
</li>
<li style="line-height: 1.6;">hibernate shards / ibatis shards</li>
</ol>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">分布式事务</li>
<li style="line-height: 1.6;">跨节点join</li>
<li style="line-height: 1.6;">跨节点合并排序分页<br style="margin-top: 0px;"/>都由应用解决吧</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">参考书籍：</h1>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6; margin-top: 0px;">《高性能MySQL》</li>
<li style="line-height: 1.6;">张宴的《MySQL调优与架构设计》</li>
</ol>
</div>