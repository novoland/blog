<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>二进制索引树(树状数组)</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">网络<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">非递归的二叉树遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">二进制索引树(树状数组)</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">概述</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">二进制索引树通常用一个数组实现，它的思路是用数组下标的二进制表达节点在树中的位置。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每个节点存储该位置的元素与其左子树代表所有节点之和，只适用于求区间和问题。  </p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">例子：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">原始数组 raw:
[ <span style="color: #ae81ff;">5</span>] [ <span style="color: #ae81ff;">1</span>] [<span style="color: #ae81ff;">15</span>] [<span style="color: #ae81ff;">11</span>] [<span style="color: #ae81ff;">52</span>] [<span style="color: #ae81ff;">28</span>] [ <span style="color: #ae81ff;">0</span>]
  <span style="color: #ae81ff;">1</span>    <span style="color: #ae81ff;">2</span>    <span style="color: #ae81ff;">3</span>    <span style="color: #ae81ff;">4</span>    <span style="color: #ae81ff;">5</span>    <span style="color: #ae81ff;">6</span>    <span style="color: #ae81ff;">7</span>

对应的二进制索引树 tree（与原始数组等长）:
[ <span style="color: #ae81ff;">5</span>] [ <span style="color: #ae81ff;">6</span>] [<span style="color: #ae81ff;">15</span>] [<span style="color: #ae81ff;">32</span>] [<span style="color: #ae81ff;">52</span>] [<span style="color: #ae81ff;">80</span>] [ <span style="color: #ae81ff;">0</span>]
  <span style="color: #ae81ff;">1</span>    <span style="color: #ae81ff;">2</span>    <span style="color: #ae81ff;">3</span>    <span style="color: #ae81ff;">4</span>    <span style="color: #ae81ff;">5</span>    <span style="color: #ae81ff;">6</span>    <span style="color: #ae81ff;">7</span>

图形化:
                 <span style="color: #ae81ff;">4</span>
                [<span style="color: #ae81ff;">32</span>]
              /     \
           <span style="color: #ae81ff;">2</span>           <span style="color: #ae81ff;">6</span>
          [<span style="color: #ae81ff;">6</span>]         [<span style="color: #ae81ff;">80</span>]
         /   \       /   \
        <span style="color: #ae81ff;">1</span>     <span style="color: #ae81ff;">3</span>     <span style="color: #ae81ff;">5</span>     <span style="color: #ae81ff;">7</span>
       [<span style="color: #ae81ff;">5</span>]  [<span style="color: #ae81ff;">15</span>]   [<span style="color: #ae81ff;">52</span>]  [<span style="color: #ae81ff;">0</span>]

tree[<span style="color: #ae81ff;">6</span>] = raw[<span style="color: #ae81ff;">5</span>,<span style="color: #ae81ff;">6</span>] 之和
tree[<span style="color: #ae81ff;">4</span>] = raw[<span style="color: #ae81ff;">1</span>,<span style="color: #ae81ff;">2</span>,<span style="color: #ae81ff;">3</span>,<span style="color: #ae81ff;">4</span>] 之和
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">无论原始数组是什么样子，二进制索引树的结构是不变的</strong>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">节点在树中的位置，是由该节点在数组中下标的二进制形式决定的：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">            <span style="color: #ae81ff;">100</span>
           [+<span style="color: #ae81ff;">37</span>]
          /     \
      <span style="color: #ae81ff;">010</span>         <span style="color: #ae81ff;">110</span>
     [+<span style="color: #ae81ff;">11</span>]       [+<span style="color: #ae81ff;">80</span>]
     /   \       /   \
   <span style="color: #ae81ff;">001</span>   <span style="color: #ae81ff;">011</span>   <span style="color: #ae81ff;">101</span>   <span style="color: #ae81ff;">111</span>
  [+<span style="color: #ae81ff;">10</span>] [+<span style="color: #ae81ff;">15</span>] [+<span style="color: #ae81ff;">52</span>] [ +<span style="color: #ae81ff;">0</span>]

将每个下标最后一个<span style="color: #ae81ff;">1</span>及其后续bit位去掉，就变成了：

          (empty)
           [+<span style="color: #ae81ff;">37</span>]
          /     \
       <span style="color: #ae81ff;">0</span>           <span style="color: #ae81ff;">1</span>
     [+<span style="color: #ae81ff;">11</span>]       [+<span style="color: #ae81ff;">80</span>]
     /   \       /   \
    <span style="color: #ae81ff;">00</span>   <span style="color: #ae81ff;">01</span>     <span style="color: #ae81ff;">10</span>   <span style="color: #ae81ff;">11</span>
  [+<span style="color: #ae81ff;">10</span>] [+<span style="color: #ae81ff;">15</span>] [+<span style="color: #ae81ff;">52</span>] [ +<span style="color: #ae81ff;">0</span>]
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果把 0 定义为左，1定义为右，那么节点在数组的下标就代表着从根到自己的路径；因此，给定一个下标，就能推导出它到根的路径。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">注意，原始数组和树数组的下标都是从1开始的，通常位置0被废弃不用。</strong></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">操作</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">二进制索引树支持以下操作：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">update(i)</code>：更新raw[i]</li>
<li style="line-height: 1.6;">查询<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">sum(i)</code>： 查询raw[1..i]的和</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两个操作的时间复杂度都是<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;">O(log2N)</code>。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">单点更新</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当更新数组 raw 中某个元素(下标为i)时，会影响 BIT 中哪些节点呢？</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">首先，显然会影响 tree[i] 的值；<br/>从该节点向根回溯，因为节点值包含了左子树之和，因此在回溯的过程中，只要碰到一根 <strong style="font-weight: bold;">左边</strong>（意味着 tree[i] 属于它的左子树），就要更新该边的目标节点（方向是向上走的）；<br/>最后，tree[i] 所有的孩子节点则不会受到影响。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如何找到这些节点呢？</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">观察可知，从 i 开始，<strong style="font-weight: bold;">不停地将 i 最后的 1 进位</strong>，直到超出数组长度，所得到的就是会被影响的点。如上面例子中，如果更新 1 处的值，需要更新的节点为 001--010--100；如果更新 5，则需要更新的节点为 101--110， 符合要求。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">求 [1..i] 之和</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">求和的过程和更新很类似，依然是从节点 i 开始向上回溯，但这次要找的是 <strong style="font-weight: bold;">右边</strong>，即碰到一根右边就把节点的值加上。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">求这些节点下标的算法也类似，只不过现在要 <strong style="font-weight: bold;">不停地去掉 i 最后的 1</strong>，直到0。如求 [0..5]，101--100，即将 tree[4] 与 tree[5] 相加即可。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">实现</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">到此，所有问题集中在如何求 i 二进制形式最后的 1，算法很简单：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">lowbit</span><span style="color: #f8f8f2;">(i)</span>:</span>
    <span style="color: #F92672;">return</span> i &amp; (-i)
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">因此，整个 BIT 的实现如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">raw = [<span style="color: #F92672;">None</span>,<span style="color: #ae81ff;">5</span>,<span style="color: #ae81ff;">1</span>,<span style="color: #ae81ff;">15</span>,<span style="color: #ae81ff;">11</span>,<span style="color: #ae81ff;">52</span>,<span style="color: #ae81ff;">28</span>,<span style="color: #ae81ff;">0</span>]  <span style="color: #75715e;"># 原始数组</span>
BIT = [<span style="color: #ae81ff;">0</span>] * len(raw)    <span style="color: #75715e;"># 二进制索引树</span>
<span style="color: #75715e;"># 二者索引都是从1开始</span>

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">lowbit</span><span style="color: #f8f8f2;">(i)</span>:</span>
    <span style="color: #F92672;">return</span> i&amp;(-i)

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">initBIT</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> range(<span style="color: #ae81ff;">1</span>,len(raw)):
        add(i,raw[i])

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">sum</span><span style="color: #f8f8f2;">(i)</span>:</span>
    sum = <span style="color: #ae81ff;">0</span>
    <span style="color: #F92672;">while</span> i &gt; <span style="color: #ae81ff;">0</span>:
        sum += BIT[i]
        i -= lowbit(i)
    <span style="color: #F92672;">return</span> sum

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">add</span><span style="color: #f8f8f2;">(i,u)</span>:</span>
    <span style="color: #F92672;">while</span> i &lt; len(BIT):
        BIT[i] += u
        i += lowbit(i)
</code></pre>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">应用：求逆序数</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数组 a 中，对于位置 i，如果它前面存在 n 个比 a[i] 大的数，则称 i 处的逆序数等于 n。 求逆序数是二进制索引树的典型应用。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">假设有范围在[1,5]的若干个数组成的数组，求每个位置的逆序数。一个很直观的想法是遍历，对位置i，统计前面比它大的数即可。其实也可以换一种统计方式：统计前面&lt;= a[i] 的数的数量，然后用 i 减去结果，剩下的就是大于 a[i] 的数量了。因此，我们需要一种手段查询 <strong style="font-weight: bold;">所有从1到a[i]之间数字的出现次数</strong>，这可以通过一个 BIT 实现，该 BIT 维护 [1,5] 之每个数字的出现次数。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">举个例子，假如数组为 [5,2,1,4,3]，当遍历到数字 4 时，我们已经知道它的前面有 3 个位置，通过 BIT 又能快速知道 1/2/3/4 这4个数字已经出现过的总次数（2），二者相减就能得到此处的逆序数；最后更新 BIT，为数字 4 的出现次数加 1。就这样边计算逆序数边维护 BIT，即能求得数组中所有位置的逆序数。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">可以看到，BIT 的构造依赖于数组中所有数字的取值范围，上例是[1,5]，刚好适用；若范围是个很大的数字，则需要将其映射到[1,n]的形式，这是一个比较简单的转换。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">代码如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">s = [<span style="color: #ae81ff;">5</span>,<span style="color: #ae81ff;">2</span>,<span style="color: #ae81ff;">1</span>,<span style="color: #ae81ff;">4</span>,<span style="color: #ae81ff;">3</span>,<span style="color: #ae81ff;">2</span>,<span style="color: #ae81ff;">1</span>,<span style="color: #ae81ff;">3</span>,<span style="color: #ae81ff;">5</span>,<span style="color: #ae81ff;">3</span>,<span style="color: #ae81ff;">2</span>,<span style="color: #ae81ff;">1</span>]   <span style="color: #75715e;"># 待求逆序数的数组</span>
tree = [<span style="color: #ae81ff;">0</span>] * (<span style="color: #ae81ff;">5</span> + <span style="color: #ae81ff;">1</span>)            <span style="color: #75715e;"># BIT，长度由数字范围决定</span>
result = [<span style="color: #F92672;">None</span>] * len(s)        <span style="color: #75715e;"># 所有位置的逆序数</span>

<span style="color: #75715e;"># 入口函数</span>
<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">cal</span><span style="color: #f8f8f2;">()</span>:</span>
    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> range(len(s)):
        number = s[i]
        result[i] = i - sum(number)  <span style="color: #75715e;"># 逆序数 = 前面位置数 - 前面[1..number]出现个数</span>
        add(number,<span style="color: #ae81ff;">1</span>)   <span style="color: #75715e;"># 更新 BIT</span>
    <span style="color: #F92672;">print</span> result

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">add</span><span style="color: #f8f8f2;">(i,inc)</span>:</span>
    <span style="color: #F92672;">while</span> i &lt; len(tree):
        tree[i] += inc
        i += lowbit(i)

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">sum</span><span style="color: #f8f8f2;">(i)</span>:</span>
    sum = <span style="color: #ae81ff;">0</span>
    <span style="color: #F92672;">while</span> i &gt; <span style="color: #ae81ff;">0</span>:
        sum += tree[i]
        i -= lowbit(i)
    <span style="color: #F92672;">return</span> sum

cal()   <span style="color: #75715e;"># [0, 1, 2, 1, 2, 3, 5, 2, 0, 3, 6, 9]</span>
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">很多问题都可以转变成 逆序数 的模型：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">求冒泡排序过程中需要交换的次数</strong></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 每存在一对逆序的数字就要交换一次，这等于所有位置的逆序数之和。</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">有一堆赛车手比赛，每个赛车手都有出发和到达时间，计算每个车手的分数。规则为：score = 所有出发比自己晚但是到达比自己早的车手数量之和。（所有的出发时间和到达时间没有重复的）</strong></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 先将所有车手按到达时间排个序，然后问题就成了：对车手i，其得分为前面所有出发时间比他晚的车手个数，即逆序数。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 这个题目需要区间映射。</p>
</li>
</ol>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html&text=二进制索引树(树状数组)" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html&title=二进制索引树(树状数组)" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
