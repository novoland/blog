<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>KMP</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">网络<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">非递归的二叉树遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">KMP</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：在字符串txt（长为m）中匹配pattern（长为n）字符串。</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">1. KMP原理</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">暴力求解时使用两个指针i和j，匹配失败时，i回溯至该次匹配起始点+1的位置，j回溯至0，然后继续同时移动匹配，复杂度为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">O(m*n)</code>。KMP的精髓在于，当匹配失败时能够利用已经匹配成功的j个字符的性质回溯j指针，不需要回溯i，从而将遍历txt的时间缩短为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">O(m)</code>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">举例说明，假设txt="abababaabab"，pattern="ababacb"，初始i=j=0，开始同时往右移动进行匹配，第一次匹配失败时的情况如下所示：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378544180.png" name="72dc6e9d-576c-4bf3-ba13-8c9001daadae" src="/assets/img/8a833b8f5c21f2620786ac37d1f50899.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">方框表示的是当前Pattern正和Txt中哪部分子串进行比对。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">此时，注意到 从i往前回溯3个字符 和 pattern开始的3个字符 是一样的，如图中下划线所示，都是“aba”，我们可以利用这个特点，不回溯i，直接回退j到“aba”的后面，i、j再次同时右移进行比较，如下图所示：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378738286.png" name="ed5e416e-c871-499b-8a3f-e4cee8125211" src="/assets/img/dbd14cc5f28783239a47fef7c7a89769.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">回溯j时，我们充分利用了已经匹配成功的部分子串的“对称性”，即从匹配失败的i处开始往前，总有一小部分字符是和Pattern的前几个字符相同的，在刚刚的例子里是“aba”（姑且称之为“对称子串”）。因此，在下次匹配时可以将j回退到该对称子串的右侧，直接跳过这些字符，再同i匹配；如果没有对称子串，j只能回溯到0，这种情况的处理下面会提到。不管是哪种情况，都不需要回溯i指针。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">ok，此时i和j指向的元素恰好相同，于是继续同时右移，下一次匹配失败发生在两步之后：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378752269.png" name="979dd5a7-1f79-4792-98c0-f5a2ee982743" src="/assets/img/017d25875cd70849e5c4b33d866753d1.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">同样的，找到失败时的 已匹配子串“ababa”的对称子串“aba”（如图中下划线所示），将j回退到该子串的右侧继续和i同时右移比对，于是便成了：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378766750.png" name="41467fa1-63bf-4984-84e0-86f0e572b101" src="/assets/img/44e562f72205507db5e6ea675c417461.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">i和j继续比对，这次立马就失败了，于是继续回溯j到对称子串“a”的右侧：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378809582.png" name="e4d8d185-1dea-4910-8d67-64d1312ac173" src="/assets/img/18951d766fd6183b97d0beab5a067429.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">继续比对，但这次还是失败，j只能回溯到0。当j==0时，固定j，i向右移动直到txt[i] == pattern[0]：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378836401.png" name="27afa2e7-a104-4aa3-93ca-1210027b69be" src="/assets/img/ea8213c6f0bce32f52101789f11833ea.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">重复以上的过程，当j指向pattern最后一个元素且i、j对应的字符相等时，匹配成功。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题来了，当回溯j时如何知道要回溯到哪个位置？根据前文的描述，当匹配失败时，j需要回溯到前j-1个字符的“对称子串”的右侧（没有则回溯到0），而对称子串仅与pattern本身的性质（对称性）有关，因此，我们完全可以预处理pattern，对每个位置j，计算出当在j处匹配失败时 j需要回退的位置，存放这些信息的数组我们称之为next数组。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">总结一下利用next数组进行匹配的过程：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">i=j=0；</li>
<li style="line-height: 1.6;">j和i同时往右走进行比对，相等时若j指向pattern最末则匹配成功，失败时j根据next[j]回退并继续比对；</li>
<li style="line-height: 1.6;">每次回退后判断j是否==0，j==0时固定j，i向后遍历直到txt[i] == pattern[0]，此时跳转到2。<br/>将上述逻辑“直译”成代码则如下所示：</li>
</ol>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;">public</span> <span style="color: #F92672;">int</span> <span style="color: #a6e22e;">search</span>(String txt) {

    <span style="color: #F92672;">int</span> i = <span style="color: #ae81ff;">0</span>, j = <span style="color: #ae81ff;">0</span>;
    <span style="color: #F92672;">int</span> txtLen = txt.length();
    <span style="color: #F92672;">int</span> patternLen = pattern.length();

    <span style="color: #F92672;">while</span> (i &lt; txtLen) {
        <span style="color: #75715e;">// i/j同时右移匹配</span>
        <span style="color: #F92672;">for</span> (; txt.charAt(i) == pattern.charAt(j); i++, j++) {
            <span style="color: #75715e;">//j指向pattern最末时，匹配成功</span>
            <span style="color: #F92672;">if</span> (j == patternLen - <span style="color: #ae81ff;">1</span>)
                <span style="color: #F92672;">return</span> i - j;
        }

        <span style="color: #75715e;">// 匹配失败，j回溯</span>
        j = next[j];

        <span style="color: #75715e;">// j回溯至0时，i向后遍历直到txt[i]和pattern[0]相等</span>
        <span style="color: #F92672;">if</span> (j == <span style="color: #ae81ff;">0</span>) {
            <span style="color: #F92672;">while</span> (i &lt; txtLen &amp;&amp; txt.charAt(i) != pattern.charAt(<span style="color: #ae81ff;">0</span>))
                i++;
        }
    }

    <span style="color: #F92672;">return</span> -<span style="color: #ae81ff;">1</span>;
}
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">代码可以更精简，但目前这样更方便我自己记忆和理解整个逻辑。</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">2. Next数组</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">现在考虑怎么求next数组，我们知道，next[j]有两重含义：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378870297.png" name="91c56644-05dd-4cd7-9207-c1309de9877a" src="/assets/img/5cab704bbfca26fd636690b5ba94a2ca.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">Pattern[0 ... j-1]</code>的（最大）对称子串长度 = <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j]</code>：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 即<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">Pattern[0 ... j-1]</code>的前next[j]个字符和后<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j]</code>个字符是相同的；</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在j处匹配失败时，j指针需要回退的位置：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"> 即<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">Pattern[0 ... j-1]</code>的对称子串的右侧；不存在对称子串时next[j]=0，表示j必须回退到第一个元素。</p>
</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最简单的求法是用两个指针在0 ... j-1段一个往后一个往前探测，但每求一个位置的next[j]都要这个过程，显然重复了很多计算工作。实际上，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j+1]</code>可以由已经求的的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[0]</code> ... <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j]</code>计算得到。先看 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j]</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j+1]</code> 的关系，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j]</code>的含义是 0...j-1 的最大对称子串长度，此时只需查看 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">pattern[ next[j] ]</code> 和 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">pattern[j]</code> （如下图黑色箭头所指），如果二者相等，那么<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j+1] = next[j] + 1</code>，如下图所示：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378880664.png" name="eb2c68e2-e66f-4b93-8115-051c347920a5" src="/assets/img/5d93ab8992ed919dd576ae7408ad3a73.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果运气没那么好，这两个元素不等，该怎么办？我们可以继续考察0...j-1的最大对称子串的对称性，即上图中的绿色区域的对称性，如下所示：</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1406378894114.png" name="90927dea-15f0-44d0-b98a-9f5eee59287f" src="/assets/img/6f8e8d8e71b83e642df69a7624b7b99b.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">此时我们要拿 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[ next[j] ]</code> 指向的元素（上图第一个箭头）和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">pattern[j]</code>（上图第二个箭头）比较，如果相等则<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j+1] = next[ next[j] ] + 1</code>；如果不等则循环这个过程。可以想象成不停地缩小查找的对称区域，一开始是查看j左侧所有元素的对称子串，接下来是该对称子串（绿色部分）的对称子串（蓝色部分），不满足条件就接着查看对称子串的对称子串的对称子串。。。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当遇到0时循环结束，说明查找完所有可能的对称子串都不满足要求，此时我们只能查看<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">pattern[0]</code>和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">pattern[j]</code>，如果相等，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">next[j+1]=1</code>，说明<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">0 ... j</code>的最大对称子串长度为1；否则=0，说明<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">0 ... j</code>内不具有对称性。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">将上面这个过程翻译过来，代码如下：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">private <span style="color: #F92672;">int</span>[] <span style="color: #F92672;">next</span>;
private String pattern;
public KMP(String pattern) {
    this.pattern = pattern;
    <span style="color: #F92672;">next</span> = new <span style="color: #F92672;">int</span>[pattern.<span style="color: #F92672;">length</span>()];
    <span style="color: #ae81ff;">//</span> 初始化<span style="color: #F92672;">next</span>[<span style="color: #ae81ff;">0</span>]和<span style="color: #F92672;">next</span>[<span style="color: #ae81ff;">1</span>]，均为<span style="color: #ae81ff;">0</span>
    <span style="color: #F92672;">next</span>[<span style="color: #ae81ff;">0</span>] = <span style="color: #ae81ff;">0</span>;
    <span style="color: #F92672;">if</span> (pattern.<span style="color: #F92672;">length</span>() &lt;= <span style="color: #ae81ff;">1</span>)
        <span style="color: #F92672;">return</span>;
    <span style="color: #F92672;">next</span>[<span style="color: #ae81ff;">1</span>] = <span style="color: #ae81ff;">0</span>;

    loop: <span style="color: #F92672;">for</span> (<span style="color: #F92672;">int</span> j = <span style="color: #ae81ff;">2</span>; j &lt; pattern.<span style="color: #F92672;">length</span>(); j++) {
        <span style="color: #F92672;">int</span> pre = j - <span style="color: #ae81ff;">1</span>;    <span style="color: #ae81ff;">//</span> j前一个元素，在寻找过程中要和它做比较

        <span style="color: #F92672;">int</span> k = <span style="color: #F92672;">next</span>[pre];
        <span style="color: #F92672;">while</span> (k != <span style="color: #ae81ff;">0</span>) {
            <span style="color: #ae81ff;">//</span> 查找成功，进行下次循环，求<span style="color: #F92672;">next</span>[j+<span style="color: #ae81ff;">1</span>]
            <span style="color: #F92672;">if</span> (pattern.charAt(pre) == pattern.charAt(k)) {
                <span style="color: #F92672;">next</span>[j] = k + <span style="color: #ae81ff;">1</span>;
                <span style="color: #F92672;">continue</span> loop;
            }
            // 否则继续查找内部对称子串
            k = <span style="color: #F92672;">next</span>[k];
        }

        // k == <span style="color: #ae81ff;">0</span>，说明没有满足要求的对称子串，只能查看pattern[<span style="color: #ae81ff;">0</span>] 和 pattern[pre]是否相等
        <span style="color: #F92672;">next</span>[j] = pattern.charAt(pre) == pattern.charAt(<span style="color: #ae81ff;">0</span>) ? <span style="color: #ae81ff;">1</span> : <span style="color: #ae81ff;">0</span>;
    }
}
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">同样的，代码也不是最精简的，但是和之前描述的逻辑是一致的，更容易看懂和理解。</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">3. 复杂度</h1>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">时间复杂度：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">O(m+n)</code> //遍历txt+生成next数组</li>
<li style="line-height: 1.6;">空间复杂度：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">O(n)</code> //next数组</li>
<li style="line-height: 1.6;">时间复杂度的分析要用到“摊还分析”，看了很久还没太理解，暂且按下不表。</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">4. 测试</h1>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #F92672;">void</span> <span style="color: #a6e22e;">main</span>(String[] args) {
    String pattern = <span style="color: #e6db74;">"PARTICIPATEINPARACHUTE"</span>;
    KMP rk = <span style="color: #F92672;">new</span> KMP(pattern);
    String txt = <span style="color: #e6db74;">"fdjkajjjfppPPPPPPPPPARTICIPATEINPARACHUTE"</span>;
    System.<span style="color: #F92672;">out</span>.println(txt);
    <span style="color: #F92672;">int</span> index = rk.search(txt);
    <span style="color: #F92672;">if</span> (index &gt;= <span style="color: #ae81ff;">0</span>) {
        <span style="color: #F92672;">for</span> (<span style="color: #F92672;">int</span> i = <span style="color: #ae81ff;">0</span>; i &lt; index; i++) {
            System.<span style="color: #F92672;">out</span>.print(<span style="color: #e6db74;">" "</span>);
        }
        System.<span style="color: #F92672;">out</span>.print(pattern);
    }
}
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">输出</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;">fdjkajjjfppPPPPPPPPPARTICIPATEINPARACHUTE</span>
                   PARTICIPATEINPARACHUTE
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">next数组为：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">[<span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">1</span>, <span style="color: #ae81ff;">2</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">1</span>, <span style="color: #ae81ff;">2</span>, <span style="color: #ae81ff;">3</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #ae81ff;">0</span>]
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">参考资料</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><a href="http://chaoswork.com/blog/2011/06/14/kmp%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/" style="background: transparent;" target="_blank">KMP算法小结</a></li>
<li style="line-height: 1.6;"><a href="http://www.matrix67.com/blog/archives/115" style="background: transparent;" target="_blank">KMP算法详解 @Matrix67</a></li>
</ol>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html&text=KMP" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html&title=KMP" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
