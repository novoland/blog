<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>线段树</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">网络<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">非递归的二叉树遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">线段树</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">结构</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1405924933637.png" name="83469ba4-d53f-4406-829b-e0144e7e424c" src="/assets/img/452338c4f7751cd55052264d8a231221.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">特点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">完全二叉树</li>
<li style="line-height: 1.6;">每个节点代表一个区间，孩子节点分别代表两个子区间</li>
<li style="line-height: 1.6;">节点保存着 <strong style="font-weight: bold;">该区间内问题的解</strong>，以及求解需要的其他数据</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">用一个数组保存，和 heap 结构类似。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">分治，要求能够从若干子区间的解推导出父区间的解，且对父区间的更新可以传导给子区间</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">适用于区间查询 / 区间维护等问题</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">操作</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">线段树支持以下操作：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">构造</li>
<li style="line-height: 1.6;">更新<ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">单点更新</li>
<li style="line-height: 1.6;">区间更新</li>
</ul>
</li>
<li style="line-height: 1.6;">区间查询</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">以区间和问题为例：</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">构造</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">O(N)</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;">tree = <span style="color: #F92672;">None</span>
<span style="color: #75715e;">#### Utils</span>
<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">eval</span><span style="color: #f8f8f2;">(i)</span>:</span>
    <span style="color: #e6db74;">"""
    由孩子节点计算某节点的 sum
    """</span>
    tree[i][<span style="color: #e6db74;">'sum'</span>] = tree[lc(i)][<span style="color: #e6db74;">'sum'</span>] + tree[rc(i)][<span style="color: #e6db74;">'sum'</span>]    

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">lc</span><span style="color: #f8f8f2;">(i)</span>:</span>
    <span style="color: #e6db74;">"""
    左孩子
    """</span>
    <span style="color: #F92672;">return</span> <span style="color: #ae81ff;">2</span>*(i+<span style="color: #ae81ff;">1</span>) - <span style="color: #ae81ff;">1</span>

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">rc</span><span style="color: #f8f8f2;">(i)</span>:</span>
    <span style="color: #e6db74;">"""
    右孩子
    """</span>
    <span style="color: #F92672;">return</span> <span style="color: #ae81ff;">2</span>*(i+<span style="color: #ae81ff;">1</span>)

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">mid</span><span style="color: #f8f8f2;">(i)</span>:</span>
    <span style="color: #e6db74;">"""
    计算节点所代表区间的中间位置
    """</span>
    <span style="color: #F92672;">return</span> tree[i][<span style="color: #e6db74;">'start'</span>] + (tree[i][<span style="color: #e6db74;">'end'</span>]-tree[i][<span style="color: #e6db74;">'start'</span>])/<span style="color: #ae81ff;">2</span>
<span style="color: #75715e;">####</span>

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">init</span><span style="color: #f8f8f2;">(array)</span>:</span>
    <span style="color: #F92672;">global</span> tree

    <span style="color: #75715e;"># 计算线段树节点个数，完全二叉树的节点数 = 2^(height+1) - 1</span>
    length = len(array) <span style="color: #75715e;"># range length</span>
    height = math.ceil(math.log(length,<span style="color: #ae81ff;">2</span>)) 
    maxSize = int(math.pow(<span style="color: #ae81ff;">2</span>,height + <span style="color: #ae81ff;">1</span>) - <span style="color: #ae81ff;">1</span>) 

    _init(array,<span style="color: #ae81ff;">0</span>,<span style="color: #ae81ff;">0</span>,length - <span style="color: #ae81ff;">1</span>) <span style="color: #75715e;"># 默认区间为数组下标区间</span>

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">_init</span><span style="color: #f8f8f2;">(array,i,s,e)</span>:</span>
    <span style="color: #e6db74;">"""
    构造一棵线段树，节点格式：{start:1,end:2,sum:8}
    array -- 原始数组
    i -- 根节点
    s -- 根节点代表的区间开始处
    e -- 根节点代表的区间结束处
    """</span>
    tree[i] = {<span style="color: #e6db74;">'start'</span>:s,<span style="color: #e6db74;">'end'</span>:e,<span style="color: #e6db74;">'sum'</span>:<span style="color: #F92672;">None</span>}
    <span style="color: #75715e;">## 如果是原子区间，即叶子节点</span>
    <span style="color: #F92672;">if</span> s == e:
        tree[i][<span style="color: #e6db74;">'sum'</span>] = array[s]
        <span style="color: #F92672;">return</span>

    _init(array, lc(i), s, mid(i))
    _init(array, rc(i), mid(i) + <span style="color: #ae81ff;">1</span>, e)
    eval(i)
</code></pre>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">单点更新</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">O(log2N)</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">update</span><span style="color: #f8f8f2;">(i,value)</span>:</span>    
    _update(<span style="color: #ae81ff;">0</span>,i,value)

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">_update</span><span style="color: #f8f8f2;">(root,i,value)</span>:</span>
    <span style="color: #75715e;"># 找到了这个点，更新其sum并返回</span>
    <span style="color: #F92672;">if</span> tree[root][<span style="color: #e6db74;">'start'</span>] == i <span style="color: #F92672;">and</span> tree[root][<span style="color: #e6db74;">'end'</span>] == i:
        tree[root][<span style="color: #e6db74;">'sum'</span>] = value
        <span style="color: #F92672;">return</span>
    <span style="color: #F92672;">if</span> i&lt;= mid(root):
        _update(lc(root),i,value)
    <span style="color: #F92672;">else</span>:
        _update(rc(root),i,value)
    eval(root)
</code></pre>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">区间更新</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">O(log2N)</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">基本思路是将要修改的区间顺着根一层一层往下查找，直到找到一批子区间刚好组成目标区间，再将更新动作应用在这些区间内。比如文章开始的线段树中，如果要更新[1,7]，则可以在树中找到节点[1,5], [6,7]刚好凑成[1,7]，更新这两个区间，重新计算二者祖先节点值即可。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题是[1,5]并不是叶子节点，如果将以它为根的整个子树全部更新，那么一次更新的动作涉及到的节点就很多了。因此引入延迟更新的思路：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">当更新[1,5]时，只更新该节点，并给它加上一个更新动作的标记，子节点不更新。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">查询或修改时，如果碰到了节点[1,5]，并决定进入其子节点考察，为了不访问到错误的值，需要看[1,5]的更新标记，如果有，则将更新动作应用到子节点，并清除自身的标记。子节点的更新则继续 lazy 的思路。</p>
</blockquote><pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">rangeUpdate</span><span style="color: #f8f8f2;">(start,end,value)</span>:</span>
    _rangeUpdate(<span style="color: #ae81ff;">0</span>,start,end,value)

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">_rangeUpdate</span><span style="color: #f8f8f2;">(root,start,end,value)</span>:</span>
    <span style="color: #e6db74;">"""
    线段树的区间update，必须满足父区间的update可以传递到左右子区间.
    -- 即update(a,b)的效果 等价于 update(a,i) &amp; update(i+1,b).

    lazy update后，其子树的data是过时的, 因此 rangeUpdate 和 query 时，在进入孩子节点考察前，必须先将父节点的 update 动作推送给它的左右孩子。
    """</span>
    <span style="color: #75715e;"># 到了某个最大组成子区间，lazy更新并返回</span>
    <span style="color: #F92672;">if</span> tree[root][<span style="color: #e6db74;">'start'</span>] == start <span style="color: #F92672;">and</span> tree[root][<span style="color: #e6db74;">'end'</span>] == end:
        tree[root][<span style="color: #e6db74;">'sum'</span>] = (end - start + <span style="color: #ae81ff;">1</span>) * value
        tree[root][<span style="color: #e6db74;">'update'</span>] = value    <span style="color: #75715e;"># 标记</span>
        <span style="color: #F92672;">return</span>

    <span style="color: #75715e;"># 推送更新动作到子区间</span>
    _pushDownUpdate(root)

    <span style="color: #75715e;"># 更新子区间</span>
    <span style="color: #F92672;">if</span> end &lt;= mid(root):
        _rangeUpdate(lc(root),start,end,value)
    <span style="color: #F92672;">elif</span> start &gt; mid(root):
        _rangeUpdate(rc(root),start,end,value)
    <span style="color: #F92672;">else</span>:
        _rangeUpdate(lc(root),start,mid(root),value)
        _rangeUpdate(rc(root),mid(root) + <span style="color: #ae81ff;">1</span>,end,value)

    <span style="color: #75715e;"># 子区间更新完毕，重新计算当前节点的值</span>
    eval(root)    

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">_pushDownUpdate</span><span style="color: #f8f8f2;">(parent)</span>:</span>
    <span style="color: #e6db74;">"""
    将update动作传递给孩子
    """</span>
    p = tree[parent] <span style="color: #75715e;"># parent</span>
    <span style="color: #F92672;">if</span> <span style="color: #e6db74;">'update'</span> <span style="color: #F92672;">in</span> p:
        u = p[<span style="color: #e6db74;">'update'</span>]
        l = tree[lc(parent)] <span style="color: #75715e;"># left child</span>
        r = tree[rc(parent)] <span style="color: #75715e;"># right child</span>
        <span style="color: #75715e;"># 给左右子区间记录update动作</span>
        l[<span style="color: #e6db74;">'update'</span>] = r[<span style="color: #e6db74;">'update'</span>] = u
        <span style="color: #75715e;"># 更新左右子区间</span>
        l[<span style="color: #e6db74;">'sum'</span>] = (l[<span style="color: #e6db74;">'end'</span>] - l[<span style="color: #e6db74;">'start'</span>] + <span style="color: #ae81ff;">1</span>) * u
        r[<span style="color: #e6db74;">'sum'</span>] = (r[<span style="color: #e6db74;">'end'</span>] - r[<span style="color: #e6db74;">'start'</span>] + <span style="color: #ae81ff;">1</span>) * u
        <span style="color: #75715e;"># 清除父区间的update动作</span>
        <span style="color: #F92672;">del</span> p[<span style="color: #e6db74;">'update'</span>]
</code></pre>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">区间查询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">O(log2N)</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">找最大组成子区间，merge结果</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">query</span><span style="color: #f8f8f2;">(start,end)</span>:</span>
    <span style="color: #F92672;">return</span> _query(<span style="color: #ae81ff;">0</span>,start,end)

<span style="color: #F92672;"><span style="color: #66d9ef;">def</span> <span style="color: #a6e22e;">_query</span><span style="color: #f8f8f2;">(root,start,end)</span>:</span>
    <span style="color: #e6db74;">"""
    对root的子区间进行查询, [start,end]必须是root所代表的子区间
    """</span>
    <span style="color: #75715e;"># 查询的区间就是root的区间时，直接返回root保存的data</span>
    <span style="color: #F92672;">if</span> tree[root][<span style="color: #e6db74;">'start'</span>] == start <span style="color: #F92672;">and</span> tree[root][<span style="color: #e6db74;">'end'</span>] == end:
        <span style="color: #F92672;">return</span> tree[root][<span style="color: #e6db74;">'sum'</span>]

    _pushDownUpdate(root)

    <span style="color: #75715e;"># [start,end]:</span>
    <span style="color: #75715e;"># 1. 如果在左子区间内，进入左子树</span>
    <span style="color: #F92672;">if</span> end &lt;= mid(root):
        <span style="color: #F92672;">return</span> _query(lc(root),start,end)

    <span style="color: #75715e;"># 2. 如果在右子区间内，进入右子树</span>
    <span style="color: #F92672;">if</span> start &gt; mid(root):
        <span style="color: #F92672;">return</span> _query(rc(root),start,end)

    <span style="color: #75715e;"># 3. 跨越了左右子区间，则将[start,end]拆分为[start,mid] &amp; [mid+1,end]，</span>
    <span style="color: #75715e;">#    分别进入左右子树查询，并merge这两个区间上的查询结果</span>
    <span style="color: #F92672;">return</span> _query(lc(root),start,mid(root)) + _query(rc(root),mid(root) + <span style="color: #ae81ff;">1</span>,end)
</code></pre>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html&text=线段树" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html&title=线段树" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
