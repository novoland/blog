<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>TCP</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">网络<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">非递归的二叉树遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">TCP</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">ack是接收端期望接收到的数据序号，等于已接收到序号+1。</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">1. 有连接的：建立和终止</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">三次握手</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">SYN ACK+SYN ACK</li>
<li style="line-height: 1.6;">被动连接端的ACK通过SYN<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">捎带</code></li>
<li style="line-height: 1.6;">交换双方的： 初始序列号 / MSS / 窗口大小（？）</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">四次挥手</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">FIN ACK FIN ACK</li>
<li style="line-height: 1.6;">单向关闭</li>
<li style="line-height: 1.6;">半关闭。通过半关闭向另一端告知数据发送完毕。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">状态变换：</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1401174323234.png" name="c6428ae2-b0b5-4fc5-835a-01b6b0e551dc" src="/assets/img/1b7d77e4bd3391e09d1ada152392c072.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1401174353330.png" name="e8c6cd20-be3f-4c5e-b2f6-be429eff673d" src="/assets/img/6d971061f8715b70ddb1b19ff0397478.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">MSS</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">根据物理层的MTU计算，避免IP层分段</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2MSL（TIME_WAIT）状态</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><em>主动关闭端</em>在发送对FIN的最后一个ACK后，等待2MSL时间。MSL, max segment lifetime，一个segment在网络中存活的最长时间。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">原因：</p>
<ul style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">被动关闭端可能没有收到ACK而重发FIN，如果不等待，这个重发的FIN可能将新的连接关闭掉；</li>
<li style="line-height: 1.6;">网络中可能还有在传输的旧的重传报文段，可能被当做新连接的数据。</li>
</ul>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">等2MSL：一个ACK+FIN的最大时间，如果在这个时间段内没有收到重发的FIN，认为对方已经收到ACK正确关闭了。</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">处于2MSL状态的端口不能被使用。客户端每次连接随机选一个端口，因此没有影响；而服务器端固定端口，因此在服务器端主动关闭，必须等待一段时间才能重新绑定到原端口。设置选项<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">SO_REUSEADDR</code>可以取消这个设定。</li>
<li style="line-height: 1.6;">在此期间拒绝任何收到的数据。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">RST</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">TCP模块会在自己认为的异常时刻发送RST；</li>
<li style="line-height: 1.6;">不会对RST发ACK，立即丢弃缓冲区中的数据；</li>
<li style="line-height: 1.6;">用RST而不是FIN关闭连接，称为<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">abortive release</code>（相对<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">orderly release</code>）；api会通知应用层连接是异常关闭的。</li>
<li style="line-height: 1.6;">常见的产生时机：<ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">连接到/发送数据到没有使用的端口，收到RST</li>
<li style="line-height: 1.6;">关闭连接时接收缓冲区有数据，将发送RST</li>
<li style="line-height: 1.6;">向一个已经close()的socket发送数据，将收到RST ---- close和shutdown虽然都是发送FIN关闭连接，但前者的语义是关闭读写，后者是关闭写，但依然能读。</li>
</ul>
</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">同时打开</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两端都是主动打开。SYN SYN+ACK / SYN SYN+ACK。4个segment。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">同时关闭</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两端都是主动关闭，FIN ACK / FIN ACK，两端最后都进入2MSL状态。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">并发TCP服务器</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Listen的服务器在接受连接后，创建一个ESTABLISHED的连接，Listen的依然存在，二者在服务器端公用一个端口。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Listen状态的socket在接收连接请求后，内核会创建一个新的established状态的socket；原socket依然是listen状态；二者在服务器端使用同一个端口。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">backlog队列</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">服务器端的TCP模块内有一个连接队列，保存所有已被TCP接受（三次握手完成），但未被应用层接受的连接；队列的长度由应用层指定，称为backlog；</li>
<li style="line-height: 1.6;"><em>TCP连接的建立</em> 和 <em>应用层得到一个已经建立的连接</em>，是一个<em>生产者消费者模型</em>；应用层无法拒绝客户端的连接请求。</li>
<li style="line-height: 1.6;">客户端发起连接成功后，该连接在服务器端可能只在backlog队列中，此时客户端如果发送数据，将被缓存在TCP接收buffer中；</li>
<li style="line-height: 1.6;">backlog队列满后，不会回应发来的FIN，让客户端重试。如果backlog队列一直满，客户端终将超时。</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">2. 滑动窗口</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">Urgent Mode</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">URG标志位为1时，说明报文段是紧急数据，需要尽快被应用进程接收和处理。普通数据在接收端是按序接收的，紧急模式在两端间建立了一个<strong style="font-weight: bold;">独立于普通数据的<em>逻辑信道</em></strong>，接收端通常将普通数据和紧急数据分开存放，二者之间不遵守有序的规则，越过普通数据而直接读取后面的紧急数据。这种数据也被称为”带外数据“（out-of-band data），但实际上，他们和普通数据是共享物理信道的。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">delayed ack</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">接收端不立即发送ack，而是等待一段时间，和数据一起发送，或和另一个ack合并成一个发送。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">滑动窗口的工作方式</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">窗口通知：<br/>发送端维护发送窗口大小（不传输），接收端在ACK中告知接收窗口大小；</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">发送窗口初始是发送缓冲区大小，接收窗口初始是接收缓冲区大小；缓冲区决定窗口的最大值；</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">发送窗口一般包括3个部分，从左到右：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">已发送但未收到ACK的数据</li>
<li style="line-height: 1.6;">可以立即发送的数据</li>
<li style="line-height: 1.6;">空闲空间；</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">接收窗口就是接收缓冲区还剩多少空间，接收端处理能力越强，从缓冲区提取数据的速度就越快，接收窗口就越大；</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">发送窗口大小由接收窗口决定，发送端收到ACK后：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">丢弃缓存中对应的数据，左沿向右移动；</li>
<li style="line-height: 1.6;">根据ACK告知的接收窗口看是否需要移动右沿；</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">作用：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">提高效率，可以同时发送多个数据；</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold;">流量控制，适配不同处理能力的发送端和接收端</strong></li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最优窗口大小（即发送/接收缓冲区大小）的计算：</p>
<ul style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">尽量将两端之间的信道填满；</li>
<li style="line-height: 1.6;">填满时，在信道上传输的数据 = 带宽（数据传输速度） * RTT，两个缓冲区应至少为这个大小</li>
</ul>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">问题1：零窗口</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">接收端接收缓冲区满时，ACK中接收窗口为0，阻止发送端发送数据。发送方需要在接收方缓冲区空出来时得到通知，因此在发现零窗口后会进行<em>窗口探测</em>，即定时发送含有1字节内容的segment，通过其ACK查询接收方的接收窗口。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">问题2：糊涂窗口综合症 (silly window syndrome)</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">现象：大量的小segment被传输（payload太小），造成网络利用率低下</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">发送端和接收端都有可能引起这种情况：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">发送端每次只发送少量数据；</li>
<li style="line-height: 1.6;">接收端的处理能力不够或应用层没有即时从接收缓冲区中取数据，接收窗口一直很小，发送端只能发小segment。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">解决：<br/><strong style="font-weight: bold;"> 发送端: nagle算法 </strong></p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">只针对<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">小segment</code>的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">stop-wait</code>协议，大segment不受影响；</li>
<li style="line-height: 1.6;">在前一个 <strong style="font-weight: bold;">小segment</strong>（小于MSS）的ack未到来前，缓存并合并其他要发送的小segment；</li>
<li style="line-height: 1.6;">如果ack回来的很快，合并不了多少数据；</li>
<li style="line-height: 1.6;">ack通常是delayed，会导致数据发送的延时；不适合实时性的应用（可以取消）；</li>
<li style="line-height: 1.6;">目的是减少segment数目。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> 接收端: </strong><br/>在接收端，当接收窗口小于一定阈值（如MSS一半）时，无论是数据确认ACK，还是对窗口探测的回应ACK，都宣告接收窗口为0，阻止发送端发送小报文段。</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">3. 可靠性：超时重传</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每个segment发送后都会有一个计时器负责接收ACK，如果超时，则重新发送该segment。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">首先要预测当前发送的segment的RTT：<br/>R = αR + (1-α)M，M是测量到的RTT，R是估计的RTT。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">然后计算RTO(Retransmission TimeOut):<br/>简单版：RTO = R*β<br/>复杂版，将RTT的估计值，RTT的偏差的估计值也考虑在内：</p>
<pre style="overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;" xml:space="preserve"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;"><span style="color: #66d9ef;">Err</span> = <span style="color: #66d9ef;">M</span> - <span style="color: #66d9ef;">R</span>  <span style="color: #75715e;">#Err是实际RTT和估计RTT的差值</span>
<span style="color: #66d9ef;">R</span> = <span style="color: #66d9ef;">R</span> + g*<span style="color: #66d9ef;">Err</span> = (<span style="color: #ae81ff;">1</span>-g)*<span style="color: #66d9ef;">R</span> + g*<span style="color: #66d9ef;">M</span> <span style="color: #75715e;">#计算估计RTT，和之前的算法一模一样</span>
<span style="color: #66d9ef;">D</span> = <span style="color: #66d9ef;">D</span> + h*(|<span style="color: #66d9ef;">Err</span>| - <span style="color: #66d9ef;">D</span>) <span style="color: #75715e;"># 计算估计偏差，”估计偏差“指的是 估计RTT 和 真实RTT  的差值。这个算法和估计RTT的计算方法是一样的</span>
<span style="color: #66d9ef;">RTO</span> = <span style="color: #66d9ef;">R</span> + <span style="color: #ae81ff;">4</span>D <span style="color: #75715e;">#</span>
</code></pre>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">多次重传时RTO的exponential backoff（指数退避）</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">4. 顺序性</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数据乱序到达，接收端可以不丢弃，而是缓冲起来，组装成有序后交付给应用进程。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">快速重传</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">接收端在接收到乱序segment时，用重复ACK提醒发送端空洞的存在，使之发送丢失数据，保证可靠性。<br/>例：发送端发送了5/6/7/8/9，假如接收端按顺序接收5/9/7/8，6丢失了，则在接收到9/7/8后均会发送ACK=6；当发送端收到3个重复的值为7的ack时认为6丢失了，打断6的超时timer并立即重新发送。<br/>为什么阈值是3呢？这是一个权衡，重复ACK可能是由段丢失引起的，但也可能只是段乱序到达了而已，比如5/7/8/6/9，在7和8处会发送两个重复的ACK，但是紧接着6就到了，接收端重组后一切正常，此时也不会触发发送端的<em>快速重传</em>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优点：接收端利用空洞后的segment比超时更快地检测到丢失片段，效率更高。</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">5. 拥塞控制</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：堵塞 --&gt; 数据丢失 --&gt; 超时重传 --&gt; 更堵塞</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">解决办法：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">探测堵塞; </li>
<li style="line-height: 1.6;">发现堵塞时控制自己发送数据的速度。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">探测堵塞</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">上文已经提到了各种推测segment丢失的办法：超时 / 重复ACK，<strong style="font-weight: bold;">一旦出现段丢失则认为堵塞</strong>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">但是注意，这两种情况下的阻塞程度不一样：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">超时：严重阻塞，发送了若干段但是一个ACK都没回来；</li>
<li style="line-height: 1.6;">重复ACK：轻微阻塞，或者没有阻塞。因为后续的段到达了，只有中间某些段没有到达。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">控制速度</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">单纯的滑动窗口中，发送方通过接收方通告的接收窗口大小调整发送窗口，从而控制发送速度；为了拥塞控制，TCP还会在发送端维护一个<em>拥塞窗口</em>，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">真实发送窗口= min(接收窗口，拥塞窗口)</code>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">拥塞控制有3个阶段：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">慢启动(slow start) </li>
<li style="line-height: 1.6;">拥塞避免(congestion avoidance)</li>
<li style="line-height: 1.6;">快速恢复（相对快速重传而言）</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">// cwnd： 拥塞窗口大小</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">慢启动</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">系统从slow start阶段开始。在这一阶段cwnd被置为1，只能发送1个segment；每收到1个ack，都给拥塞窗口+1，即下次可以发送2个段，下下次可以发送4个段，即乘性倍增。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">拥塞避免</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当cwnd增长到某个阈值ssthresh(slow start threshhold)时，拥塞窗口进入congestion avoidance状态。此时发送窗口在每个窗口中所有片段都传输完毕后，将拥塞窗口+1，线性缓慢增长。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在congestion avoidance状态下，一旦出现探测到拥塞，ssthresh更新为当前cwnd的一半，随后分两种情况：如果是ACK超时检测到的拥塞，则进入slow start；<strong style="font-weight: bold;">如果是重复ACK，则进入快速恢复阶段</strong>。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">快速恢复</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">cwnd增加3个segment的长度，以后每收到一个重复的ACK，就再增加1个segment长度。这是因为一个重复ACK说明有一个段已被发送出去，可以发送另一个段了；</li>
<li style="line-height: 1.6;">当收到一个非重复ACK时，说明对方的数据接收完整了，发送端将cwnds复原为sthresh的一半，重新回到congestion avoidance状态。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">分开处理的原因正如前所述，两种情况表达的拥塞程度不同。对超时表达的严重堵塞，需严厉地立刻降低发送速率，因此直接进入慢启动阶段；对重复ACK，说明双方仍然有数据流动，我们不希望执行slow start突然减少数据流。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果在slow start阶段就出现丢失数据，则slow start立刻开始，ssthresh更新为cwnd的一半。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1400765487595.png" name="4c1097c3-df4b-4994-a311-eca5c6892e64" src="/assets/img/4a26ce1a352129b148ba26f27f53016d.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">总体来说，拥塞窗口的状态变迁是一个试探性的过程。slow start阶段起步速度低，不太可能出现拥塞，因此发送速度可以快速攀升；congestion avoidance阶段速度接近饱和，采用更保守的方式，速度缓慢增长逼近极限。一旦探测到拥塞，就将slow start的拐点降低为当前拥塞窗口的一半，且如果是严重堵塞，则立即重置，避免网络负担；如果是轻微拥塞，则快速恢复。</p>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html&text=TCP" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html&title=TCP" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
